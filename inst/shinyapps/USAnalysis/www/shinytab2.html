<body> <div id="shinytab2" class="section level2">&#13;
<h2>The Model</h2>&#13;
<div id="model-overview" class="section level3">&#13;
<h3>Model Overview</h3>&#13;
<p>The model is the continous time model in the ‘basic bacteria model’ app. See the documentation there for the model description. For convenience, here is a quick summary and the equations again.</p>&#13;
<p>We model 2 compartments:</p>&#13;
<ul><li><strong>B</strong> - bacteria</li>&#13;
<li><strong>I</strong> - immune response</li>&#13;
</ul><p>We specify the following processes/flows:</p>&#13;
<ol style="list-style-type: decimal"><li>Bacteria grow/divide at some maximum rate (which we label <em>g</em>) and saturate as they approach some maximum carrying capacity, <em>B<sub>max</sub></em>.</li>&#13;
<li>Bacteria die at a natural death rate (which we label <em>d<sub>B</sub></em>).</li>&#13;
<li>Bacteria are killed by the immune response at some rate <em>k</em>.</li>&#13;
<li>The immune response grows proportional to the number of bacteria and itself at some rate <em>r</em>.</li>&#13;
<li>The immune response decays at some rate (which we label <em>d<sub>I</sub></em>).</li>&#13;
</ol><p>The equations are given by:</p>&#13;
<p><span class="math display">\[\dot B = g B (1-\frac{B}{B_{max}}) - d_B B - k BI\]</span> <span class="math display">\[\dot I = r B I - d_I I\]</span></p>&#13;
</div>&#13;
<div id="uncertainty-and-sensitivity-analysis" class="section level3">&#13;
<h3>Uncertainty and Sensitivity analysis</h3>&#13;
<p>Often, for a given system we want to model, we only have rough estimates for the model parameters and starting values. Instead of specifying fixed values (which results in a single time-series), we can instead specify parameter ranges, choose sets of parameter values from these ranges, and run the model for multiple sets of parameters.</p>&#13;
<p>The simplest way of specifying parameter ranges is to set an upper and lower bound (based on what we know about the biology of the system) and randomly choose any value within those bounds. We can almost always set bounds even if we know very little about a system. Assume we want to model the death rate of some cell type (e.g. NK cells) in humans. We might not know anything, but we can still be fairly confident that their lifespan is at least 1 second and less than 100 years. That’s of course a wide range and we should and usually can narrow ranges further, based on biological knowledge of a given system.</p>&#13;
<p>If we are fairly certain that values are close to some quantity, instead of specifying a uniform distribution, we can choose one that is more peaked around the most likely value. Normal distributions are not ideal since they allow negative values, which doesn’t make sense for our parameters. The gamma distribution is a better idea, since it leads to only positive values.</p>&#13;
<p>To run the model for this app, we need to specify values for the 2 initial conditions, <em>B<sub>0</sub></em> and <em>I<sub>0</sub></em>, and the 6 model parameters <em>g</em>, <em>B<sub>max</sub></em>, <em>d<sub>B</sub></em>, <em>k</em>, <em>r</em>, <em>d<sub>I</sub></em>. All initial conditions and parameters are sampled uniformly between the specified upper and lower bound, apart from the bacteria growth rate, which is given by a gamma distribution, with user-specified mean and variance. For this teaching app, there is no biological reason for making bacterial growth different, I just picked one parameter and decided to make it non-uniformly distributed to show you different ways one can implement distributions from which to draw parameter samples.</p>&#13;
<p>The way the samples are drawn could be done completely randomly, but that would lead to inefficient sampling. A smarter method exists, known as Latin Hypercube sampling (LHS). It essentially ensures that we sample the full range of possible parameter combinations in an efficient manner. For more technical details, see [@]. For this app, we use LHS.</p>&#13;
<p>Once we specify the ranges for each parameter, the sampling method, and the number of samples, the simulation draws that many samples, runs the model for each sample, and records outcomes of interest. While the underlying simulation returns a time-series for each sample, we are usually not interested in the full time-series. Instead, we are interested in some summary quantity. For instance in this model, we might be interested in the maximum/peak level of bacteria during the infection, the level of bacteria at the end (the steady state) of the infection, and the level of the immune response at steady state. This app records and reports those 3 quantities as <em>B<sub>peak</sub></em>, <em>B<sub>steady</sub></em> and <em>I<sub>steady</sub></em>.</p>&#13;
<p>Results from such simulations for multiple samples can be analyzed in different ways. The most basic one, called <em>uncertainty analysis</em> only asks what level of uncertainty we have in our outcomes of interest, given the amount of uncertainty in our model parameter values. This can be graphically represented with a boxplot, and is one of the plot options for this app.</p>&#13;
<p>In a next step, we can ask ‘how sensitive is the outcome(s) of interest to variation in specific parameters’ - that part is the <em>sensitivity analysis</em>. When you run the simulations, you essentially do both uncertainty and sensitivity analysis at the same time, it’s just a question of how you further process the results. We can graphically insoect the relation between outcome and some parameter with scatterplots. If we find that there is a monotone up or down (or neither) trend between parameter and outcome, we can also summarize the finding using a correlation coefficient. For this type of analysis, using the Spearman rank correlation coefficient is useful, which is what the app produces below the figures.</p>&#13;
</div>&#13;
<div id="a-note-on-randomness-in-computer-simulations" class="section level3">&#13;
<h3>A note on randomness in computer simulations</h3>&#13;
<p>This simulation (as well as some of the others) involves sampling. This leads to some level of randomness. In science, we want to be as reproducible as possible. Fortunately, random numbers on a computer are not completely random, but can be reproduced. In practice, this is done by specifing a random number seed, in essence a starting position for the algorithm to produce pseudo-random numbers. As long as the seed is the same, the code should produce the same pseudo-random numbers each time, thus ensuring reproducibility.</p>&#13;
</div>&#13;
</div> </body>
